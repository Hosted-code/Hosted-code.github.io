---
title: Regexp 使用
date: 2020-07-05 11:31:27
categories:
  - Tool
  - CheatSheet
tags:
  - Tool
  - CheatSheet
---



# 正则

正则, **文本匹配**的工具, 能更精确的描述需求

![Regexp](https://cdn.jsdelivr.net/gh/Hosted-code/CloudImg@master/20200706221746.png)



# 背景

 早之前为了避免将 `==` 误写为 `=` , 人们一般习惯将常量放在左侧,  如 `5 == flag`, 这样当误写为`5 = flag`, 编译器就会报错, 这种也被视作是好的书写习惯

但如今, 这种错误可以通过**静态检查工具**检视出来, 以及通过设置**编译选项**来使得在编译过程中就可防范该类错误, 因此无需牺牲可读性, 而使用这种 "优秀的书写习惯". 

> 通过设置`-Wall -Werror`, 启用所有警告, 并在将warning视为 error, 如此便能发现 **条件判断中的赋值语句**
>
> **让工具去解决笔误问题, 代码要符合可读性第一**

公司要求整改代码时, 便遇到了大量常量位于运算符左侧的代码, 这种写法不符合公司编码规范, 因此借用**正则表达式**来实现快速替换

使用该正则, 可批量替换代码中运算符右侧**非函数的情况**

`([A-Z0-9_]+) (==|!=)([->\.\[\]\w]+)(?!\()` => `$3 $2 $1`

涉及函数的情况, 贪婪非贪婪均无法精确匹配到对应层次的括号,  **平衡组可实现**, 但无论使用的编辑器vim还是vscode均不支持该种特性,  python支持该特性, 但为免引入问题, 涉及函数的手动变更

正则在做提取和替换方面还是很高效的, 因此做如下总结, 常用元字符之类的, 就仅在上文思维导图中体现



# 位置匹配 - 断言

**六个概念**

- **零宽**: 只**匹配位置**，在匹配过程中，**不占用字符**
- **正向**：匹配括号中的表达式,  `=`
- **负向**: 不匹配括号中表达式,  `!`
- 正则引擎**从左到右**扫描字符
  - **先行**, 匹配未扫描到的字符, 先于扫描指针, 
  - **后行**, 匹配已扫描到的字符, 后于扫描指针.  `<`,  表明返回匹配已扫描的字符
- **断言**: 断言为真时继续进行匹配。`?`

**零宽正向先行断言,** `(?=pattern)`, **某位置后面紧接着的字符序列要匹配 pattern**

**零宽负向先行断言,** `(?!pattern)`,  **某位置后面紧接着的字符序列不能匹配 pattern**

**零宽正向后行断言,** `(?<=pattern)`, **某位置前面紧接着的字符序列要匹配 pattern**

**零宽负向后行断言,** `(?<!pattern)`, **某位置前面紧接着的字符序列不能匹配 pattern**



# 平衡组

平衡组，故名思义，平衡即对称，**主要是结合几种正则语法规则，提供对配对出现的嵌套结构的匹配。**

四种语法结果

- 维护命名栈
  - `(?<group>)`, 命名组, 压栈
  - `(?<-group>)`, 命名组, 出栈, `-`
- `(?!)`, 零宽负向先行断言, pattern为`""`, 匹配总是失败
- `(?(group)yes|no)`, 判断堆栈, 不为空匹配yes, 为空匹配no
  - `(?(group)(?!))`, 堆栈不为空, 则匹配失败

该段正则可匹配成对括号匹配, `\(((?<mm>\()|(?<-mm>\))|[^()]+)*(?(mm)(?!))\)`

下图则为对正则表达式的解析

![平衡组](https://cdn.jsdelivr.net/gh/Hosted-code/CloudImg@master/20200706222709.png)



# 参考链接

[Regex/CheatSheet](https://ihateregex.io/cheatsheet)

[正则表达式30分钟入门教程](https://deerchao.cn/tutorials/regex/regex.htm)

[正则表达式——详细讲解平衡组](https://blog.csdn.net/zm2714/article/details/7946437)

[关于正则位置匹配（断言）的技巧](https://juejin.im/post/5b583fede51d4516e91f9e2f)